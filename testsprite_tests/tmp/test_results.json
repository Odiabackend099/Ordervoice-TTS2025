[
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "8b051307-6990-4aa1-aaf8-a646061cefc7",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC001-Landing Page Localization and Content Display",
    "description": "Verify that the Landing Page loads correctly with all localized Nigerian content, including Nigerian English text, pricing displayed in Nigerian Naira (₦), testimonials, and team information.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Verify pricing is displayed correctly in Nigerian Naira (₦) by navigating to the Pricing section.\n        frame = context.pages[-1]\n        # Click on the Pricing link to verify pricing in Nigerian Naira\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down or extract content to verify the testimonials section is present with expected testimonial content.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Navigate back to the Landing Page to check for testimonials and team information sections.\n        frame = context.pages[-1]\n        # Click on Home link to return to the Landing Page\n        elem = frame.locator('xpath=html/body/nav/div/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down the landing page to locate and verify the testimonials section and its content.\n        await page.mouse.wheel(0, 1000)\n        \n\n        # -> Scroll further or extract content to locate and verify the team section with accurate team member details on the landing page.\n        await page.mouse.wheel(0, 1000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Never Miss a Client Call Again').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=OrderVoice AI is your intelligent AI receptionist that answers every call, qualifies leads, and books appointments — 24/7. Built specifically for Nigerian clinics, law firms, real estate agents, and growing businesses. Your AI assistant that never sleeps.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=₦40,000/month').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=₦95,000/month').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=₦220,000/month').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Before OrderVoice, we were missing 30-40 calls daily while in court or with clients. Now every potential client gets answered immediately, qualified, and booked for consultation. Our intake process runs 24/7. Best investment we\\'ve made.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=We used to pay a receptionist ₦120,000 monthly, plus she couldn\\'t work nights or weekends when many patients actually want to book. OrderVoice answers 24/7, never calls in sick, and patients love the instant response. Game changer.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AE Austyn Eguale CEO & FOUNDER \"Democratizing AI for Every Nigerian Business\"').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=BN Benjamin Nwoye CO-FOUNDER & DIRECTOR OF OPERATIONS \"Scaling Nigerian Businesses Through Intelligent Operations\"').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=EJ Eva Jensen CO-FOUNDER & DIRECTOR OF MEDIA AUTOMATION \"Amplifying African Voices Through Smart Media Technology\"').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that the Landing Page loads correctly with all localized Nigerian content, specifically checking that the pricing is displayed in Nigerian Naira (₦). The last action involved clicking on the Pricing link to navigate to the relevant section. However, the click action failed due to a timeout error, indicating that the system was unable to complete the navigation within the allotted time (5000ms). \n\nThe error message suggests that while the element was found and appeared to be visible and stable, the subsequent navigation did not complete in time. This could be due to several reasons:\n1. **Slow Page Load**: The Pricing page may take longer to load than expected, causing the timeout.\n2. **JavaScript Execution**: There might be JavaScript on the page that delays the navigation or causes it to hang.\n3. **Network Issues**: If there are network delays, this could also affect the loading time of the Pricing page.\n\nTo resolve this issue, consider increasing the timeout duration or checking the network performance to ensure that the page loads within an acceptable timeframe. Additionally, reviewing the JavaScript execution on the page may help identify any potential bottlenecks.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052620034681//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.184Z",
    "modified": "2025-10-21T13:17:00.176Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "8fcba813-5416-4b11-b708-deb5a291b76a",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC002-Pricing Page Tier Details and CTAs",
    "description": "Ensure the Pricing Page displays correct tier-based plans (Starter, Pro, Business) with accurate Nigerian Naira (₦) prices and functional call-to-action buttons.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Pricing link in the top navigation to go to the Pricing page.\n        frame = context.pages[-1]\n        # Click on the Pricing link in the top navigation to navigate to the Pricing page.\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to locate and verify the FAQs section on the Pricing page.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Test that CTAs (Start Free Trial and Contact Sales buttons) are clickable and initiate the expected workflow.\n        frame = context.pages[-1]\n        # Click Start Free Trial button under Starter plan to test CTA functionality.\n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Contact Sales' button under the Business plan to verify it is clickable and initiates the expected workflow.\n        frame = context.pages[-1]\n        # Click the 'Contact Sales' button under the Business plan to test CTA functionality.\n        elem = frame.locator('xpath=html/body/div/div/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Starter (₦40,000/month)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pro (₦95,000/month)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Business (₦220,000/month)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=We Contact You - Within 1 hour to discuss your needs').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Quick Setup - We configure OrderVoice for your business').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Go Live - Your AI receptionist answers calls within 24 hours').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Free Trial - Use it free for 7 days, no card needed').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Submit & Start Free Trial →').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Contact us to start your 7-day free trial or ask any questions. We typically respond within 1 hour.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test aimed to verify that the Pricing Page displays the correct tier-based plans and that the 'Start Free Trial' button functions properly. However, the click action on the button failed due to a timeout error. This indicates that while the button was visible and enabled, the expected navigation did not occur within the allotted time (5000ms). \n\nThe error message suggests that the click action was performed successfully, but the subsequent navigation to the next page did not complete in time. This could be due to several reasons:\n1. **Slow Page Load**: The page may take longer to load than expected, causing the navigation to exceed the timeout limit.\n2. **JavaScript Errors**: There might be JavaScript errors on the page that prevent the navigation from completing.\n3. **Network Issues**: If there are network delays, the navigation could be affected.\n\nTo resolve this, consider increasing the timeout duration or checking for any underlying issues that may be causing the delay in navigation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052628180416//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.199Z",
    "modified": "2025-10-21T13:17:08.358Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "1780974e-c834-4b01-912a-3ac637b0927c",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC003-Demo Page Interactive Voice Receptionist",
    "description": "Test interactive demo page functionality, verifying voice-based AI receptionist interactions including voice input, AI processing, and audio response playback.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Click the button to initiate voice interaction via microphone input\n        frame = context.pages[-1]\n        # Click the '🗣️ Talk to Lexi Now' button to initiate voice interaction \n        elem = frame.locator('xpath=html/body/section[3]/div[2]/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Select a language and click the 'Start Talking' button to initiate voice input\n        frame = context.pages[-1]\n        # Select English language \n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        frame = context.pages[-1]\n        # Click the 'Start Talking' button to initiate voice input \n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Attempt to resolve connection error by clicking 'Try Again' button to reconnect to the voice service.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the Demo Page by clicking the 'Try Demo' link to retry the voice interaction test.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the button to initiate voice interaction via microphone input.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Voice interaction successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The interactive demo page did not exhibit expected voice-based AI receptionist interactions including voice input, AI processing, and audio response playback as per the test plan.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing halted due to lack of functional voice interaction initiation on the demo page. The 'Try Demo on WhatsApp' button does not trigger voice input or any interaction interface, blocking further test steps. Please fix this issue to enable voice interaction testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 () (at https://api.odia.dev/v1/agents/lexi_nigerian_customer_service_agent_v1/conversations:0:0)\n[ERROR] Error starting conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2729:24)\n[ERROR] Failed to start conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2621:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761053205612934//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.207Z",
    "modified": "2025-10-21T13:26:45.773Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "b32749a8-0eec-4e0e-b9c9-ca3b022ebd3a",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC004-Contact and Trial Signup Form Submission",
    "description": "Validate the Contact and Trial Signup form captures business and industry information correctly, and the direct WhatsApp link functions properly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the Contact and Trial Signup Page by clicking the appropriate link.\n        frame = context.pages[-1]\n        # Click the 'Contact' link in the top navigation to go to the Contact and Trial Signup page\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[6]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill out all required fields in the form with valid business and industry information.\n        frame = context.pages[-1]\n        # Input full name\n        elem = frame.locator('xpath=html/body/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('John Doe')\n        \n\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('john.doe@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input phone number\n        elem = frame.locator('xpath=html/body/div/div/div[2]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('+234 801 234 5678')\n        \n\n        frame = context.pages[-1]\n        # Input business name\n        elem = frame.locator('xpath=html/body/div/div/div[2]/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Doe Enterprises')\n        \n\n        # -> Submit the form and verify submission success and confirmation message.\n        frame = context.pages[-1]\n        # Click the Submit & Start Free Trial button to submit the form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Trial Signup Successful! Welcome aboard.').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The Contact and Trial Signup form submission did not show the expected confirmation message, indicating the form did not capture business and industry information correctly or the submission was unsuccessful.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761043750061974//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.214Z",
    "modified": "2025-10-21T13:15:27.952Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "646c5bec-2a95-4c71-9e92-fafbc47f686d",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC005-Voice Streaming Orchestrator Integration Flow",
    "description": "Test the end-to-end real-time voice streaming orchestration among Deepgram STT, Groq LLM, and MiniMax TTS, ensuring ultra-low latency and accurate audio processing.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Start voice streaming through the orchestrator with live input by clicking the 'Try Demo' or 'See Live Demo' button.\n        frame = context.pages[-1]\n        # Click on 'Try Demo' to start voice streaming through the orchestrator with live input \n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Click the 'Try Demo on WhatsApp' button to start voice streaming through the orchestrator with live input.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Try Demo' link in the top navigation bar to start the voice streaming demo or report the issue if no other options work.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Ultra-low latency voice streaming successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The end-to-end real-time voice streaming orchestration among Deepgram STT, Groq LLM, and MiniMax TTS did not complete successfully with ultra-low latency and accurate audio processing as required by the test plan.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761053388352549//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.219Z",
    "modified": "2025-10-21T13:29:48.493Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "8c29b8fd-3f36-4f3e-ace9-f7848752f1ba",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC006-Voice Activity Detection Accuracy",
    "description": "Verify that Voice Activity Detection (VAD) correctly and promptly detects when the user starts and stops speaking with minimal false positives or missed speech segments.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Start voice input and speak multiple phrases with natural pauses to test VAD detection.\n        frame = context.pages[-1]\n        # Click the '🗣️ Talk to Lexi Now' button to start voice input for VAD testing. \n        elem = frame.locator('xpath=html/body/section[3]/div[2]/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Select a language and click 'Start Talking' to begin voice input and speak multiple phrases with natural pauses.\n        frame = context.pages[-1]\n        # Select English as the preferred language for voice input. \n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        frame = context.pages[-1]\n        # Click the 'Start Talking' button to begin voice input for VAD testing. \n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Click 'Try Again' button to attempt reconnecting to the voice service and enable voice input for VAD testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Try Demo' to navigate to the voice input demo page to start VAD testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to find and click the 'Start Talking' button or equivalent to begin voice input for VAD testing.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/footer/div/div[2]/p[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down further to locate the 'Start Talking' button or any control to initiate voice input for VAD testing.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Scroll further down or search the page for any button or link that initiates voice input or starts the demo interaction for VAD testing.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Click the 'Start 7-Day Free Trial' button to see if it leads to a voice input interface or further steps to start voice input for VAD testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to the demo page to locate the voice input interface or 'Start Talking' button to begin VAD testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Voice Activity Detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Voice Activity Detection (VAD) did not correctly detect speech start and stop events or produced false positives during silence as per the test plan.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The voice input interface or 'Start Talking' button required for VAD testing is not accessible on the demo page. The page only offers external interaction options (call or WhatsApp) and does not support direct voice input testing. Reporting this issue and stopping further actions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 () (at https://api.odia.dev/v1/agents/lexi_nigerian_customer_service_agent_v1/conversations:0:0)\n[ERROR] Error starting conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2729:24)\n[ERROR] Failed to start conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2621:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052922995916//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.225Z",
    "modified": "2025-10-21T13:22:03.131Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "c6fafbf9-eb94-4b6d-8907-7278a35e3539",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC007-Audio Visualizer Synchronization",
    "description": "Test that the real-time Audio Visualizer displays accurate and synchronized waveform feedback for both user voice input and AI synthesized output.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Try Demo' link to initiate a voice conversation with the AI receptionist.\n        frame = context.pages[-1]\n        # Click the 'Try Demo' link to initiate a voice conversation with the AI receptionist \n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Click the 'Try Demo on WhatsApp' button to initiate a voice conversation with the AI receptionist.\n        frame = context.pages[-1]\n        # Click the 'Try Demo on WhatsApp' button to initiate a voice conversation with the AI receptionist \n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Check the current page for any embedded audio visualizer or waveform display elements that respond to voice input or AI output.\n        await page.mouse.wheel(0, 600)\n        # -> Navigate back to the homepage to check if there is a dedicated demo or test page with an embedded audio visualizer for real-time waveform feedback testing.\n        frame = context.pages[-1]\n        # Click the 'OrderVoice AI' logo to navigate back to the homepage \n        elem = frame.locator('xpath=html/body/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Switch to the valid homepage tab to continue testing the real-time audio visualizer.\n        await page.goto('http://localhost:8000/index.html', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click the 'Try Demo' link at index 3 to initiate a voice conversation with the AI receptionist and observe the audio visualizer.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check the page for any embedded real-time audio visualizer or waveform display elements that respond to voice input or AI output. If none found, explore options to initiate voice conversation or test the visualizer.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Scroll down further to check for any embedded real-time audio visualizer or waveform display elements or interactive widgets that might allow direct voice input or playback on the page.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Return to the homepage to check if there is a dedicated demo or test page with an embedded audio visualizer for real-time waveform feedback testing.\n        await page.goto('http://localhost:8000/index.html', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click the 'Talk to Lexi Now' button at index 9 to initiate a voice conversation with the AI receptionist and observe the audio visualizer for user voice input and AI output.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[3]/div[2]/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a language (e.g., English at index 5) and click the 'Start Talking' button at index 10 to initiate the voice conversation and observe the real-time audio visualizer for user voice input and AI output.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Audio Visualizer Error Detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The real-time Audio Visualizer did not display accurate and synchronized waveform feedback for both user voice input and AI synthesized output as required by the test plan.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing halted due to connection error preventing voice conversation initiation and real-time audio visualizer testing. Issue reported for resolution.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052969903016//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.231Z",
    "modified": "2025-10-21T13:22:50.125Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "16325f1e-4f5c-49a7-ac02-65a061796c83",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC008-Chat Widget Functionality and Integration",
    "description": "Verify that the embeddable Chat Widget works properly with knowledge base queries, maintains message history, shows typing indicators, and integrates with voice streaming smoothly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Try Demo' or 'See Live Demo' to access the Chat Widget or demo environment where the widget can be tested.\n        frame = context.pages[-1]\n        # Click on 'Try Demo' link to access the demo environment for the Chat Widget \n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Look for an element or button to embed or open the Chat Widget on this page.\n        await page.mouse.wheel(0, 600)\n        # -> Look for a visible Chat Widget or button to open the Chat Widget on the current page.\n        await page.mouse.wheel(0, 800)\n        # -> Click on the chat widget icon (index 5) to open the Chat Widget and start interaction.\n        frame = context.pages[-1]\n        # Click on the chat widget icon to open the Chat Widget \n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Search the page for any other Chat Widget embed options or buttons, or check for developer instructions or scripts to embed the widget manually.\n        await page.mouse.wheel(0, 1000) \n        # -> Click on the chat widget icon (index 5) to open the Chat Widget and start interaction.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Chat Widget Initialization Failed')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The embeddable Chat Widget did not function as expected. This includes failure in knowledge base query responses, message history retention, typing indicators, or voice streaming integration.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The chat widget failed to open after clicking the icon on the demo page. Further testing cannot proceed. Issue reported.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761053217411137//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.237Z",
    "modified": "2025-10-21T13:26:57.617Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "1a1b5bd2-0cab-4da0-8e79-3bdc2784445d",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC009-Configuration Management Security and Environment Setup",
    "description": "Ensure centralized Configuration Management securely stores API keys and environment-specific settings without exposure, and supports parameter customization.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Inspect configuration files and environment variables setup\n        await page.goto('http://localhost:8000/config', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Look for navigation or links related to configuration, settings, or admin to inspect configuration files and environment variables\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Search for any admin, settings, or developer-related links or buttons in the navigation or footer that might lead to configuration management\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Check navigation links for any admin, settings, or developer-related pages that might lead to configuration management\n        frame = context.pages[-1]\n        # Click 'Try Demo' link to check if it leads to a page with configuration or environment settings\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Return to homepage and check other navigation links such as Pricing, Contact, or Home for possible configuration or admin access\n        frame = context.pages[-1]\n        # Click 'Home' link to return to homepage and explore other navigation options\n        elem = frame.locator('xpath=html/body/nav/div/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Pricing' link to check if it leads to any configuration or environment settings or admin pages\n        frame = context.pages[-1]\n        # Click 'Pricing' link to explore potential configuration or admin access\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Extract visible content from the Pricing page to check for any hints or references to configuration management or environment settings, then consider alternative approaches such as checking for documentation or admin login pages.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Attempt to locate or access any admin login or settings page to inspect configuration management and test parameter customization.\n        frame = context.pages[-1]\n        # Click 'Contact' link to check for any admin or support access that might lead to configuration management\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to check for any hidden admin login or configuration management links or sections on the Contact page\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=API Key Exposure Detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Configuration Management test plan execution failed because API keys or sensitive environment-specific settings might be exposed or improperly managed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that the centralized Configuration Management securely stores API keys and environment-specific settings, and that it supports parameter customization. The last action involved clicking the 'Try Demo' link to verify if it leads to a page with configuration or environment settings. However, the action failed due to a timeout error when trying to click the specified locator for the link. \n\n### Analysis:\n1. **Task Goal**: Verify navigation to configuration management settings.\n2. **Last Action**: Attempted to click the 'Try Demo' link.\n3. **Error**: The click action timed out after 5000ms, indicating that the locator for the link could not be found or was not interactable within the specified time.\n\n### Explanation of the Error:\nThe error occurred because the script was unable to locate the 'Try Demo' link within the allotted time. This could be due to several reasons:\n- The element may not be present in the DOM at the time of the click attempt.\n- The element may be hidden or overlapped by another element, making it unclickable.\n- There could be a delay in rendering the page or the specific element after the previous action.\n\nTo resolve this issue, consider the following steps:\n- Ensure that the page has fully loaded before attempting to click the link. You might want to add a wait condition to check for the visibility of the element.\n- Verify the XPath used to locate the element to ensure it is correct and points to the intended link.\n- Check for any potential overlays or modals that might be obstructing the link.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052602768418//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.244Z",
    "modified": "2025-10-21T13:16:42.932Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "f075293e-5d9d-4bd9-b169-a6fa5983ef9d",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC010-SEO Optimization Verification",
    "description": "Validate that SEO elements such as meta tags, Open Graph data, Twitter Cards, structured schema.org data, sitemap.xml, and robots.txt are properly implemented targeting the Nigerian market.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to Pricing page and extract its source code to verify SEO elements.\n        frame = context.pages[-1]\n        # Click on Pricing link to navigate to Pricing page\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Try Demo link to navigate to the Demo page and extract its source code for SEO validation.\n        frame = context.pages[-1]\n        # Click on Try Demo link to navigate to Demo page\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Contact link to navigate to Contact page and extract its source code for SEO validation.\n        frame = context.pages[-1]\n        # Click on Contact link to navigate to Contact page\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fetch sitemap.xml from the root directory and verify URL listings correspond to public pages.\n        await page.goto('http://localhost:8000/sitemap.xml', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Fetch robots.txt from the root directory and verify rules for search engine crawlers.\n        await page.goto('http://localhost:8000/robots.txt', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=User-agent: *').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Allow: /').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sitemap: https://ordervoice.ai/sitemap.xml').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Crawl-delay: 1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Disallow: /admin/').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Disallow: /private/').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to validate SEO elements by clicking the 'Try Demo' link to navigate to the Demo page. However, the last action of clicking the link failed due to a timeout error. The error message indicates that the click action exceeded the 5000ms timeout limit, even though the element was visible and stable. This suggests that while the element was present, there may have been an issue with the page's navigation or loading process that prevented the click from successfully triggering the expected action. \n\nTo resolve this, consider increasing the timeout duration or checking for any potential issues with the page's responsiveness or JavaScript execution that could be causing delays in navigation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052629974733//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.251Z",
    "modified": "2025-10-21T13:17:10.104Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "ed1e40a0-9bda-4c97-965c-0455f7cd4a76",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC011-Security Headers and Deployment Configuration",
    "description": "Verify security configuration is applied properly through deployment settings including API key management, .gitignore usage, and security headers in Vercel deployment.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate and open vercel.json or SECURITY.md file to review security header rules and deployment best practices.\n        await page.goto('http://localhost:8000/vercel.json', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Verify that these security headers are actually served on public pages by checking HTTP response headers.\n        await page.goto('http://localhost:8000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Use alternative method to verify security headers are served on public pages, such as checking network requests or using a tool to inspect HTTP headers.\n        await page.goto('http://localhost:8000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        frame = context.pages[-1]\n        # Click Home link to reload and possibly trigger network inspection\n        elem = frame.locator('xpath=html/body/nav/div/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify API key management by checking environment variables or server-side injection to ensure API keys are not exposed on client side.\n        frame = context.pages[-1]\n        # Click 'How It Works' to explore potential API key management info or environment setup details.\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to verify API key management by checking environment variables or server-side injection through other means, such as inspecting deployment environment or configuration files if accessible.\n        await page.goto('http://localhost:8000/api/config', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Error response').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Error code: 404').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Message: File not found.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Error code explanation: 404 - Nothing matches the given URI.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify the security configuration in the Vercel deployment settings, specifically by accessing the `vercel.json` file. However, the last action attempted to navigate to `http://localhost:8000/vercel.json` but resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected timeframe, which could be due to several reasons:\n\n1. **Server Not Running**: The local server at `localhost:8000` may not be running, preventing access to the specified URL.\n2. **Incorrect URL**: The URL might be incorrect or the file `vercel.json` may not exist at that location.\n3. **Network Issues**: There could be network issues affecting the connection to the local server.\n\nTo resolve this, ensure that the local server is up and running, verify the URL for correctness, and check for any network issues. Once these are addressed, you can retry accessing the `vercel.json` file to review the security configurations.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052617753927//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.256Z",
    "modified": "2025-10-21T13:16:58.003Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "51c392d1-15d6-4e54-a32e-446325ed42de",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC012-MiniMax TTS Testing Interface Validation",
    "description": "Validate the TTS Testing Interface produces natural, intelligible Nigerian English speech outputs for diverse text inputs and voice settings without errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Locate and open the TTS Testing Interface or demo to start testing TTS outputs\n        frame = context.pages[-1]\n        # Click on 'Try Demo' to access the demo interface which may include TTS testing \n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Scroll down or explore page to find TTS Testing Interface or text input for TTS testing\n        await page.mouse.wheel(0, 600)\n        # -> Scroll further down to find the TTS Testing Interface or text input area for TTS testing\n        await page.mouse.wheel(0, 800)\n        # -> Scroll further down the page to find the TTS Testing Interface or text input area for TTS testing\n        await page.mouse.wheel(0, 800)\n        # -> Scroll further down the page or extract content to find the TTS Testing Interface or text input area for TTS testing\n        await page.mouse.wheel(0, 800)\n        # -> Navigate back to the main page to look for a direct TTS Testing Interface or alternative navigation to TTS testing\n        frame = context.pages[-1]\n        # Click on 'Home' link to return to main page and search for TTS Testing Interface \n        elem = frame.locator('xpath=html/body/nav/div/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Click on 'Try Free for 7 Days' button to explore if it leads to TTS Testing Interface or text input for TTS testing\n        frame = context.pages[-1]\n        # Click on 'Try Free for 7 Days' button \n        elem = frame.locator('xpath=html/body/section/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Scroll down the page to locate the TTS Testing Interface or text input area for TTS testing.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll down further to continue searching for the TTS Testing Interface or text input area for TTS testing.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Click on 'Try Demo' link in the top navigation to see if it leads to the TTS Testing Interface or text input area for TTS testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/nav/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to the Home page to explore other navigation options for accessing the TTS Testing Interface.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/nav/div/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Try Free for 7 Days' button to check if it leads to the TTS Testing Interface or text input area for TTS testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=This text will never appear in the TTS Testing Interface')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The TTS Testing Interface did not produce natural, intelligible Nigerian English speech outputs as expected, or synthesis errors occurred.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The website lacks a dedicated TTS Testing Interface for Nigerian English TTS testing. Multiple navigation attempts led only to live call or WhatsApp demos. Task cannot be completed as specified.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761052802109479//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.263Z",
    "modified": "2025-10-21T13:20:02.279Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "84462554-20a2-4a3c-9fe6-023bdf2b8ab3",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC013-Error Handling for Speech Recognition Failures",
    "description": "Test system behavior when Deepgram STT fails or delivers errors, verifying graceful error handling and user notification.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Try Demo' to access the voice input feature for testing STT failure simulation.\n        frame = context.pages[-1]\n        # Click on 'Try Demo' to access the voice input feature for testing STT failure simulation \n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Simulate Deepgram STT WebSocket disconnection or API error during voice input by triggering the voice input feature or relevant test control.\n        await page.mouse.wheel(0, 400)\n        # -> Since no direct UI simulation is available, attempt to simulate STT failure by clicking the WhatsApp demo button to check if any error handling or retry mechanisms appear during interaction.\n        frame = context.pages[-1]\n        # Click 'Try Demo on WhatsApp' button to initiate interaction and observe system behavior for STT failure simulation \n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Click the 'Try Demo on WhatsApp' button to simulate or trigger any error handling or retry mechanisms related to Deepgram STT failure.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Deepgram STT connection successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Deepgram STT failure was not handled gracefully. The system did not notify the user of the error, did not attempt automatic retry or fallback, or crashed unexpectedly.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue with simulating Deepgram STT failure and verifying error handling on the demo page. Stopping further testing as no actionable simulation or verification could be performed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761053093709411//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.279Z",
    "modified": "2025-10-21T13:24:53.860Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "217edeb6-d84b-4665-bf2d-31f97055e99e",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC014-Edge Case: Handling No Speech Input",
    "description": "Verify system response when user activates voice input but does not speak or the audio input is silent.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Start voice interaction by clicking the voice talk button and remain silent\n        frame = context.pages[-1]\n        # Click the '🗣️ Talk to Lexi Now' button to start voice interaction \n        elem = frame.locator('xpath=html/body/section[3]/div[2]/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Select a language and click 'Start Talking' to begin voice input and remain silent\n        frame = context.pages[-1]\n        # Select English language for voice interaction \n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        frame = context.pages[-1]\n        # Click 'Start Talking' button to start voice input and remain silent \n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Retry connection or check for alternative ways to start voice interaction to test silence detection.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Try Again' button to retry connection to voice service and attempt voice input again.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the '🗣️ Talk to Lexi Now' button to start voice interaction again and remain silent to test system response.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[3]/div[2]/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the English language option and click the 'Start Talking' button to initiate voice input and remain silent for the test.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/section[4]/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Voice input detected, but no speech was heard. Please try speaking.').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError('Test failed: The system did not provide the expected prompt or guidance after silent voice input as per the test plan.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed because the voice service connection consistently fails with a 'Connection Error' message. Unable to start voice input to verify system response to silence. Issue reported for resolution.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 () (at https://api.odia.dev/v1/agents/lexi_nigerian_customer_service_agent_v1/conversations:0:0)\n[ERROR] Error starting conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2729:24)\n[ERROR] Failed to start conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2621:24)\n[ERROR] Failed to load resource: the server responded with a status of 404 () (at https://api.odia.dev/v1/agents/lexi_nigerian_customer_service_agent_v1/conversations:0:0)\n[ERROR] Error starting conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2729:24)\n[ERROR] Failed to start conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2621:24)\n[ERROR] Failed to load resource: the server responded with a status of 404 () (at https://api.odia.dev/v1/analytics/agent-selection:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 () (at https://api.odia.dev/v1/agents/lexi_nigerian_customer_service_agent_v1/conversations:0:0)\n[ERROR] Error starting conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2729:24)\n[ERROR] Failed to start conversation: Error: Failed to create conversation session\n    at startVoiceConversation (http://localhost:8000/:2676:27)\n    at async HTMLButtonElement.<anonymous> (http://localhost:8000/:2620:17) (at http://localhost:8000/:2621:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/176105300611277//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.285Z",
    "modified": "2025-10-21T13:23:26.279Z"
  },
  {
    "projectId": "3f9af8e3-31d3-4b61-b078-52cd9fead6da",
    "testId": "0c8b36de-9bf0-4ffd-b34b-79222afea4f4",
    "userId": "04c80418-b051-70b0-d0c0-e5e5c2c1103b",
    "title": "TC015-Performance under High Load",
    "description": "Test system stability, latency, and accuracy under simulated high user load and concurrent voice interactions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Try Demo' to access the demo page for voice interaction simulation\n        frame = context.pages[-1]\n        # Click on 'Try Demo' link to access the demo page for voice interaction simulation \n        elem = frame.locator('xpath=html/body/nav/div/ul/li[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        # -> Click on 'Try Demo on WhatsApp' button to start voice interaction simulation\n        frame = context.pages[-1]\n        # Click on 'Try Demo on WhatsApp' button to start voice interaction simulation \n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000) \n        # -> Simulate multiple concurrent users using voice interactions via the Demo Page or API\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry clicking 'Try Demo on WhatsApp' button or find alternative way to simulate multiple concurrent voice interactions\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=System Overload Detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The system did not handle high user load and concurrent voice interactions as expected. Latency, request failures, or resource usage issues were detected.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/04c80418-b051-70b0-d0c0-e5e5c2c1103b/1761053407855749//tmp/test_task/result.webm",
    "created": "2025-10-21T10:46:27.293Z",
    "modified": "2025-10-21T13:30:08.025Z"
  }
]
